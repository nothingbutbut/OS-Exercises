# 协程测试
我利用cpp实现了协程相关功能：
```cpp
#include <iostream>
#include <vector>
#include <coroutine>
#include <chrono>
#include <cstdint>
#include <string>
#include <numeric>
#include <cmath>
#include <algorithm>
#include <sys/resource.h> // 用于获取内存信息 (macOS)

// 返回当前进程占用的物理内存 (单位: KB)
long get_memory_usage_kb() {
    struct rusage usage;
    if (getrusage(RUSAGE_SELF, &usage) == 0) {
#ifdef __APPLE__
        return usage.ru_maxrss / 1024; // macOS 返回的是字节
#else
        return usage.ru_maxrss;        // Linux 返回的是 KB
#endif
    }
    return 0;
}

struct CoTask {
    struct promise_type {
        CoTask get_return_object() { return CoTask{std::coroutine_handle<promise_type>::from_promise(*this)}; }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() { std::terminate(); }
    };

    std::coroutine_handle<promise_type> handle;

    explicit CoTask(std::coroutine_handle<promise_type> h) : handle(h) {}
    
    CoTask(const CoTask&) = delete;
    CoTask& operator=(const CoTask&) = delete;

    CoTask(CoTask&& other) noexcept : handle(other.handle) {
        other.handle = nullptr; // 夺取所有权
    }
    
    CoTask& operator=(CoTask&& other) noexcept {
        if (this != &other) {
            if (handle) handle.destroy();
            handle = other.handle;
            other.handle = nullptr;
        }
        return *this;
    }
    // ----------------------------------

    ~CoTask() { if (handle) handle.destroy(); }
    
    void resume() { if (handle && !handle.done()) handle.resume(); }
};

// 全局变量
std::vector<uint32_t> g_array;
size_t g_M;

CoTask worker_coroutine(size_t id, int rounds) {
    size_t prev_id = (id == 0) ? (g_M - 1) : (id - 1);
    for (int r = 0; r < rounds; ++r) {
        // 先干活，再挂起
        g_array[id] = g_array[prev_id] + 1;
        
        // 完成本轮任务，交出控制权
        co_await std::suspend_always{}; 
    }
}

int main(int argc, char* argv[]) {
    // 参数处理
    g_M = 1024; // 默认 2^10
    int rounds = 10000; // 默认跑 1万圈
    
    if (argc > 1) g_M = std::stoull(argv[1]);
    if (argc > 2) rounds = std::stoi(argv[2]);

    std::cout << "=== Coroutine Benchmark (C++20) ===" << std::endl;
    std::cout << "Coroutines (M): " << g_M << std::endl;
    std::cout << "Rounds        : " << rounds << std::endl;

    long mem_baseline = get_memory_usage_kb();
    std::cout << "Baseline Memory : " << mem_baseline << " KB" << std::endl;

    try {
        g_array.resize(g_M, 0);
    } catch (...) {
        std::cerr << "Error: Array allocation failed." << std::endl;
        return 1;
    }

    std::vector<CoTask> tasks;
    tasks.reserve(g_M);
    
    long mem_before_tasks = get_memory_usage_kb();

    for (size_t i = 0; i < g_M; ++i) {
        tasks.push_back(worker_coroutine(i, rounds));
    }
    long mem_after_tasks = get_memory_usage_kb();
    long tasks_memory_kb = mem_after_tasks - mem_before_tasks;
    double bytes_per_coroutine = (double)tasks_memory_kb * 1024.0 / g_M;

    std::cout << "Memory after tasks: " << mem_after_tasks << " KB" << std::endl;
    std::cout << "Total Task Memory : " << tasks_memory_kb << " KB" << std::endl;
    std::cout << "Per Coroutine Size: " << bytes_per_coroutine << " Bytes (Estimated)" << std::endl;
    std::cout << "-----------------------------------" << std::endl;

    std::vector<double> round_latencies_ns;
    round_latencies_ns.reserve(rounds);

    std::cout << "Starting execution..." << std::endl;

    for (int r = 0; r < rounds; ++r) {
        auto t1 = std::chrono::high_resolution_clock::now();

        // 调度一整圈：依次唤醒所有协程
        for (size_t i = 0; i < g_M; ++i) {
            tasks[i].resume();
        }

        auto t2 = std::chrono::high_resolution_clock::now();
        
        // 计算这一圈的总耗时
        double ns = (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count();
        round_latencies_ns.push_back(ns);
    }

    std::vector<double> per_switch_latencies;
    per_switch_latencies.reserve(rounds);
    for(auto total_ns : round_latencies_ns) {
        per_switch_latencies.push_back(total_ns / g_M);
    }

    // 统计学计算
    double sum = std::accumulate(per_switch_latencies.begin(), per_switch_latencies.end(), 0.0);
    double mean = sum / rounds;

    double sq_sum = std::inner_product(per_switch_latencies.begin(), per_switch_latencies.end(), 
                                       per_switch_latencies.begin(), 0.0);
    double stdev = std::sqrt(sq_sum / rounds - mean * mean);

    double min_lat = *std::min_element(per_switch_latencies.begin(), per_switch_latencies.end());
    double max_lat = *std::max_element(per_switch_latencies.begin(), per_switch_latencies.end());

    std::cout << "\n=== Performance Analysis ===" << std::endl;
    std::cout << "Total Switches  : " << (size_t)g_M * rounds << std::endl;
    std::cout << "Avg Latency     : " << mean << " ns/switch" << std::endl;
    std::cout << "Min Latency     : " << min_lat << " ns/switch" << std::endl;
    std::cout << "Max Latency     : " << max_lat << " ns/switch (Jitter Spike)" << std::endl;
    std::cout << "Jitter (StdDev) : " << stdev << " ns" << std::endl;
    
    std::cout << "\n=== Detailed Sample (First 10 rounds) ===" << std::endl;
    std::cout << "Round, Latency_ns_per_switch" << std::endl;
    for(int i=0; i<10 && i<rounds; ++i) {
        std::cout << i << ", " << per_switch_latencies[i] << std::endl;
    }
    
    std::cout << "Check Array[last]: " << g_array[g_M-1] << std::endl;

    return 0;
}
```
运行后将1024/4096/16384/65536个协程分别跑10000轮，得到`coroutine_benchmark_analysis.pdf`，可以看到协程数量增加时，平均切换延时下降，且抖动也较小。内存开销方面，每个协程大约占用64B左右的内存，非常节省。