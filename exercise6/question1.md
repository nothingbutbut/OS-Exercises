# 修改伙伴系统分配操作
1. 由小到大在空闲块中找最小可用块，如空闲块大于申请块的二倍，对可用空闲块进行二等分，直到得到合适可用空闲块。
2. 如空闲块大于申请块的4/3，对可用空闲块进行四等分，直到得到合适可用空闲块。

分析“改进伙伴系统”的存储利用率和分配释放开销。


## C语言实现
我参考了https://github.com/rcore-os/buddy_system_allocator/tree/master
中的rbuddy_system实现，将其转为C语言实现，这个实现有以下特点：
1. 使用一个二维链表来管理不同阶数的空闲块，每个阶数对应一个链表，链表中存储该阶数的所有空闲块。
2. 分配逻辑和课上讲的伙伴系统类似，但在选择空闲块时，优先选择最小可用块，并且对空闲块进行二等分以适应请求大小，即已经满足了我们的第一个要求。

在修改逻辑上，我们的第二个要求应该在第一个要求执行之后进行判断和处理，因为如果空闲块大于申请块的两倍，那么我们显然应该优先进行二等分，而不是四等分。那么分配块大小范围应该是要求块的$[\frac{4}{3}, 2)$之间，此时取$\frac{3}{4}$得到的结果是$[1, \frac{3}{2})$，其实还是有可能落到$[\frac{4}{3}, 2)$的范围内的，因此还要考虑对这3个块中最后一个块进行二等分或者四等分的情况（**虽然题干里有：“直到得到合适可用空闲块”，但是我认为这里不考虑这种情况应当也是合理的，因为过度细分显然是在用外碎片替换内碎片，这里我们单纯出于趣味性做此讨论**）

分支条件：当前块大小大于申请块的$\frac{4}{3}$倍
在分支中，我们需要做下面的事情：
1. 检查order大小是否大于等于2，毕竟如果order小于2，就无法进行四等分了
2. 将当前的order大小的块分成四份，最后一个块加入到对应order-2的链表中
3. 然后，创建一个新块来包含前三个块，作为返回值
4. 接下来需要进行一个循环，检查最后一个块的大小是否大于实际占用的大小的两倍，如果是的话，我们需要继续对其进行二等分，直到不满足条件为止（递归调用即可）
5. 再检查最后一个块的大小是否大于实际占用的大小的$\frac{4}{3}$倍，如果是的话，我们需要对其进行四等分，直到不满足条件为止（递归调用即可）
6. 最后返回block

在释放时，我们也需要做特殊处理，因为我们可能会是释放3个块了，此时我们需要检查这个块分配出去时是否是3/4分配的，如果是的话，我们需要将其分为3个块分别释放（递归调用即可）

运行结果如下：
```
Initialized heap with 1048576 bytes
Allocated 3 blocks
User memory: 6204 bytes
Actual allocated: 6336 bytes
Freed one block
User memory: 4704 bytes
Actual allocated: 4800 bytes
```
我们分配了三个块大小分别为704, 1500, 4000的内存，总共6204字节，实际分配了6336字节，存储利用率为6204/6336=97.9%，释放一个块后，存储利用率为4704/4800=98%。

## 分析
从存储利用率角度来看，这样分配可以达到相当好的存储利用率，首先，可以将之前难以利用的2倍内存占用直接减少到3/2倍，提升达到33%。递归调用的情况会进一步减少内存占用，达到更高的存储利用率，但是相应的碎片率也会提高！

从分配释放开销来看，如果我们不加入递归，那么只会在原来基础上增加一次四等分的操作，开销并不大；如果加入递归调用，由于每次递归分配时块肯定都是在变小，那么最多也不超过log(n)次递归调用，开销也不会太大。